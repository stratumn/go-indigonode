// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/stratumn/alice/cli/grpc/test/test.proto

/*
	Package test is a generated protocol buffer package.

	It is generated from these files:
		github.com/stratumn/alice/cli/grpc/test/test.proto

	It has these top-level messages:
		Message
*/
package test

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/stratumn/alice/cli/grpc/ext"

import context "context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Message_Enum int32

const (
	Message_A Message_Enum = 0
	Message_B Message_Enum = 1
)

var Message_Enum_name = map[int32]string{
	0: "A",
	1: "B",
}
var Message_Enum_value = map[string]int32{
	"A": 0,
	"B": 1,
}

func (x Message_Enum) String() string {
	return proto.EnumName(Message_Enum_name, int32(x))
}
func (Message_Enum) EnumDescriptor() ([]byte, []int) { return fileDescriptorTest, []int{0, 0} }

type Message struct {
	Noext               string         `protobuf:"bytes,1,opt,name=noext,proto3" json:"noext,omitempty"`
	Req                 string         `protobuf:"bytes,2,opt,name=req,proto3" json:"req,omitempty"`
	Str                 string         `protobuf:"bytes,10,opt,name=str,proto3" json:"str,omitempty"`
	StrRepeated         []string       `protobuf:"bytes,11,rep,name=str_repeated,json=strRepeated" json:"str_repeated,omitempty"`
	Boolean             bool           `protobuf:"varint,12,opt,name=boolean,proto3" json:"boolean,omitempty"`
	BooleanRepeated     []bool         `protobuf:"varint,13,rep,packed,name=boolean_repeated,json=booleanRepeated" json:"boolean_repeated,omitempty"`
	I32                 int32          `protobuf:"varint,14,opt,name=i32,proto3" json:"i32,omitempty"`
	I32Repeated         []uint32       `protobuf:"varint,15,rep,packed,name=i32_repeated,json=i32Repeated" json:"i32_repeated,omitempty"`
	U32                 uint32         `protobuf:"varint,16,opt,name=u32,proto3" json:"u32,omitempty"`
	U32Repeated         []uint32       `protobuf:"varint,17,rep,packed,name=u32_repeated,json=u32Repeated" json:"u32_repeated,omitempty"`
	I64                 int64          `protobuf:"varint,18,opt,name=i64,proto3" json:"i64,omitempty"`
	I64Repeated         []int64        `protobuf:"varint,19,rep,packed,name=i64_repeated,json=i64Repeated" json:"i64_repeated,omitempty"`
	U64                 uint64         `protobuf:"varint,20,opt,name=u64,proto3" json:"u64,omitempty"`
	U64Repeated         []uint64       `protobuf:"varint,21,rep,packed,name=u64_repeated,json=u64Repeated" json:"u64_repeated,omitempty"`
	Buf                 []byte         `protobuf:"bytes,22,opt,name=buf,proto3" json:"buf,omitempty"`
	BufRepeated         [][]byte       `protobuf:"bytes,23,rep,name=buf_repeated,json=bufRepeated" json:"buf_repeated,omitempty"`
	Enumeration         Message_Enum   `protobuf:"varint,30,opt,name=enumeration,proto3,enum=stratumn.alice.cli.grpc.test.Message_Enum" json:"enumeration,omitempty"`
	EnumerationRepeated []Message_Enum `protobuf:"varint,31,rep,packed,name=enumeration_repeated,json=enumerationRepeated,enum=stratumn.alice.cli.grpc.test.Message_Enum" json:"enumeration_repeated,omitempty"`
	Base58              []byte         `protobuf:"bytes,50,opt,name=base58,proto3" json:"base58,omitempty"`
	Base58Repeated      [][]byte       `protobuf:"bytes,51,rep,name=base58_repeated,json=base58Repeated" json:"base58_repeated,omitempty"`
	Multiaddr           []byte         `protobuf:"bytes,52,opt,name=multiaddr,proto3" json:"multiaddr,omitempty"`
	MultiaddrRepeated   [][]byte       `protobuf:"bytes,53,rep,name=multiaddr_repeated,json=multiaddrRepeated" json:"multiaddr_repeated,omitempty"`
	Time                int64          `protobuf:"varint,54,opt,name=time,proto3" json:"time,omitempty"`
	TimeRepeated        []int64        `protobuf:"varint,55,rep,packed,name=time_repeated,json=timeRepeated" json:"time_repeated,omitempty"`
	Duration            int64          `protobuf:"varint,56,opt,name=duration,proto3" json:"duration,omitempty"`
	DurationRepeated    []int64        `protobuf:"varint,57,rep,packed,name=duration_repeated,json=durationRepeated" json:"duration_repeated,omitempty"`
	Bytesize            uint64         `protobuf:"varint,58,opt,name=bytesize,proto3" json:"bytesize,omitempty"`
	BytesizeRepeated    []uint64       `protobuf:"varint,59,rep,packed,name=bytesize_repeated,json=bytesizeRepeated" json:"bytesize_repeated,omitempty"`
	Byterate            uint64         `protobuf:"varint,60,opt,name=byterate,proto3" json:"byterate,omitempty"`
	ByterateRepeated    []uint64       `protobuf:"varint,61,rep,packed,name=byterate_repeated,json=byterateRepeated" json:"byterate_repeated,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{0} }

func (m *Message) GetNoext() string {
	if m != nil {
		return m.Noext
	}
	return ""
}

func (m *Message) GetReq() string {
	if m != nil {
		return m.Req
	}
	return ""
}

func (m *Message) GetStr() string {
	if m != nil {
		return m.Str
	}
	return ""
}

func (m *Message) GetStrRepeated() []string {
	if m != nil {
		return m.StrRepeated
	}
	return nil
}

func (m *Message) GetBoolean() bool {
	if m != nil {
		return m.Boolean
	}
	return false
}

func (m *Message) GetBooleanRepeated() []bool {
	if m != nil {
		return m.BooleanRepeated
	}
	return nil
}

func (m *Message) GetI32() int32 {
	if m != nil {
		return m.I32
	}
	return 0
}

func (m *Message) GetI32Repeated() []uint32 {
	if m != nil {
		return m.I32Repeated
	}
	return nil
}

func (m *Message) GetU32() uint32 {
	if m != nil {
		return m.U32
	}
	return 0
}

func (m *Message) GetU32Repeated() []uint32 {
	if m != nil {
		return m.U32Repeated
	}
	return nil
}

func (m *Message) GetI64() int64 {
	if m != nil {
		return m.I64
	}
	return 0
}

func (m *Message) GetI64Repeated() []int64 {
	if m != nil {
		return m.I64Repeated
	}
	return nil
}

func (m *Message) GetU64() uint64 {
	if m != nil {
		return m.U64
	}
	return 0
}

func (m *Message) GetU64Repeated() []uint64 {
	if m != nil {
		return m.U64Repeated
	}
	return nil
}

func (m *Message) GetBuf() []byte {
	if m != nil {
		return m.Buf
	}
	return nil
}

func (m *Message) GetBufRepeated() [][]byte {
	if m != nil {
		return m.BufRepeated
	}
	return nil
}

func (m *Message) GetEnumeration() Message_Enum {
	if m != nil {
		return m.Enumeration
	}
	return Message_A
}

func (m *Message) GetEnumerationRepeated() []Message_Enum {
	if m != nil {
		return m.EnumerationRepeated
	}
	return nil
}

func (m *Message) GetBase58() []byte {
	if m != nil {
		return m.Base58
	}
	return nil
}

func (m *Message) GetBase58Repeated() [][]byte {
	if m != nil {
		return m.Base58Repeated
	}
	return nil
}

func (m *Message) GetMultiaddr() []byte {
	if m != nil {
		return m.Multiaddr
	}
	return nil
}

func (m *Message) GetMultiaddrRepeated() [][]byte {
	if m != nil {
		return m.MultiaddrRepeated
	}
	return nil
}

func (m *Message) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Message) GetTimeRepeated() []int64 {
	if m != nil {
		return m.TimeRepeated
	}
	return nil
}

func (m *Message) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Message) GetDurationRepeated() []int64 {
	if m != nil {
		return m.DurationRepeated
	}
	return nil
}

func (m *Message) GetBytesize() uint64 {
	if m != nil {
		return m.Bytesize
	}
	return 0
}

func (m *Message) GetBytesizeRepeated() []uint64 {
	if m != nil {
		return m.BytesizeRepeated
	}
	return nil
}

func (m *Message) GetByterate() uint64 {
	if m != nil {
		return m.Byterate
	}
	return 0
}

func (m *Message) GetByterateRepeated() []uint64 {
	if m != nil {
		return m.ByterateRepeated
	}
	return nil
}

func init() {
	proto.RegisterType((*Message)(nil), "stratumn.alice.cli.grpc.test.Message")
	proto.RegisterEnum("stratumn.alice.cli.grpc.test.Message_Enum", Message_Enum_name, Message_Enum_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Test service

type TestClient interface {
	UnaryReq(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
	ServerStream(ctx context.Context, in *Message, opts ...grpc.CallOption) (Test_ServerStreamClient, error)
	NoExt(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error)
}

type testClient struct {
	cc *grpc.ClientConn
}

func NewTestClient(cc *grpc.ClientConn) TestClient {
	return &testClient{cc}
}

func (c *testClient) UnaryReq(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/stratumn.alice.cli.grpc.test.Test/UnaryReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testClient) ServerStream(ctx context.Context, in *Message, opts ...grpc.CallOption) (Test_ServerStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Test_serviceDesc.Streams[0], c.cc, "/stratumn.alice.cli.grpc.test.Test/ServerStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &testServerStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Test_ServerStreamClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type testServerStreamClient struct {
	grpc.ClientStream
}

func (x *testServerStreamClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *testClient) NoExt(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/stratumn.alice.cli.grpc.test.Test/NoExt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Test service

type TestServer interface {
	UnaryReq(context.Context, *Message) (*Message, error)
	ServerStream(*Message, Test_ServerStreamServer) error
	NoExt(context.Context, *Message) (*Message, error)
}

func RegisterTestServer(s *grpc.Server, srv TestServer) {
	s.RegisterService(&_Test_serviceDesc, srv)
}

func _Test_UnaryReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServer).UnaryReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stratumn.alice.cli.grpc.test.Test/UnaryReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServer).UnaryReq(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _Test_ServerStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Message)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TestServer).ServerStream(m, &testServerStreamServer{stream})
}

type Test_ServerStreamServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type testServerStreamServer struct {
	grpc.ServerStream
}

func (x *testServerStreamServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Test_NoExt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestServer).NoExt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stratumn.alice.cli.grpc.test.Test/NoExt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestServer).NoExt(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

var _Test_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stratumn.alice.cli.grpc.test.Test",
	HandlerType: (*TestServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UnaryReq",
			Handler:    _Test_UnaryReq_Handler,
		},
		{
			MethodName: "NoExt",
			Handler:    _Test_NoExt_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServerStream",
			Handler:       _Test_ServerStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "github.com/stratumn/alice/cli/grpc/test/test.proto",
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Noext) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.Noext)))
		i += copy(dAtA[i:], m.Noext)
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	if len(m.Str) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.Str)))
		i += copy(dAtA[i:], m.Str)
	}
	if len(m.StrRepeated) > 0 {
		for _, s := range m.StrRepeated {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Boolean {
		dAtA[i] = 0x60
		i++
		if m.Boolean {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.BooleanRepeated) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.BooleanRepeated)))
		for _, b := range m.BooleanRepeated {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.I32 != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.I32))
	}
	if len(m.I32Repeated) > 0 {
		dAtA2 := make([]byte, len(m.I32Repeated)*10)
		var j1 int
		for _, num := range m.I32Repeated {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTest(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.U32 != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.U32))
	}
	if len(m.U32Repeated) > 0 {
		dAtA4 := make([]byte, len(m.U32Repeated)*10)
		var j3 int
		for _, num := range m.U32Repeated {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.I64 != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.I64))
	}
	if len(m.I64Repeated) > 0 {
		dAtA6 := make([]byte, len(m.I64Repeated)*10)
		var j5 int
		for _, num1 := range m.I64Repeated {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.U64 != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.U64))
	}
	if len(m.U64Repeated) > 0 {
		dAtA8 := make([]byte, len(m.U64Repeated)*10)
		var j7 int
		for _, num := range m.U64Repeated {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.Buf) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.Buf)))
		i += copy(dAtA[i:], m.Buf)
	}
	if len(m.BufRepeated) > 0 {
		for _, b := range m.BufRepeated {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Enumeration != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.Enumeration))
	}
	if len(m.EnumerationRepeated) > 0 {
		dAtA10 := make([]byte, len(m.EnumerationRepeated)*10)
		var j9 int
		for _, num := range m.EnumerationRepeated {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if len(m.Base58) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.Base58)))
		i += copy(dAtA[i:], m.Base58)
	}
	if len(m.Base58Repeated) > 0 {
		for _, b := range m.Base58Repeated {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Multiaddr) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.Multiaddr)))
		i += copy(dAtA[i:], m.Multiaddr)
	}
	if len(m.MultiaddrRepeated) > 0 {
		for _, b := range m.MultiaddrRepeated {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Time != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.Time))
	}
	if len(m.TimeRepeated) > 0 {
		dAtA12 := make([]byte, len(m.TimeRepeated)*10)
		var j11 int
		for _, num1 := range m.TimeRepeated {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.Duration != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.Duration))
	}
	if len(m.DurationRepeated) > 0 {
		dAtA14 := make([]byte, len(m.DurationRepeated)*10)
		var j13 int
		for _, num1 := range m.DurationRepeated {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.Bytesize != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.Bytesize))
	}
	if len(m.BytesizeRepeated) > 0 {
		dAtA16 := make([]byte, len(m.BytesizeRepeated)*10)
		var j15 int
		for _, num := range m.BytesizeRepeated {
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if m.Byterate != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.Byterate))
	}
	if len(m.ByterateRepeated) > 0 {
		dAtA18 := make([]byte, len(m.ByterateRepeated)*10)
		var j17 int
		for _, num := range m.ByterateRepeated {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func encodeVarintTest(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Message) Size() (n int) {
	var l int
	_ = l
	l = len(m.Noext)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.Str)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.StrRepeated) > 0 {
		for _, s := range m.StrRepeated {
			l = len(s)
			n += 1 + l + sovTest(uint64(l))
		}
	}
	if m.Boolean {
		n += 2
	}
	if len(m.BooleanRepeated) > 0 {
		n += 1 + sovTest(uint64(len(m.BooleanRepeated))) + len(m.BooleanRepeated)*1
	}
	if m.I32 != 0 {
		n += 1 + sovTest(uint64(m.I32))
	}
	if len(m.I32Repeated) > 0 {
		l = 0
		for _, e := range m.I32Repeated {
			l += sovTest(uint64(e))
		}
		n += 1 + sovTest(uint64(l)) + l
	}
	if m.U32 != 0 {
		n += 2 + sovTest(uint64(m.U32))
	}
	if len(m.U32Repeated) > 0 {
		l = 0
		for _, e := range m.U32Repeated {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if m.I64 != 0 {
		n += 2 + sovTest(uint64(m.I64))
	}
	if len(m.I64Repeated) > 0 {
		l = 0
		for _, e := range m.I64Repeated {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if m.U64 != 0 {
		n += 2 + sovTest(uint64(m.U64))
	}
	if len(m.U64Repeated) > 0 {
		l = 0
		for _, e := range m.U64Repeated {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	l = len(m.Buf)
	if l > 0 {
		n += 2 + l + sovTest(uint64(l))
	}
	if len(m.BufRepeated) > 0 {
		for _, b := range m.BufRepeated {
			l = len(b)
			n += 2 + l + sovTest(uint64(l))
		}
	}
	if m.Enumeration != 0 {
		n += 2 + sovTest(uint64(m.Enumeration))
	}
	if len(m.EnumerationRepeated) > 0 {
		l = 0
		for _, e := range m.EnumerationRepeated {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	l = len(m.Base58)
	if l > 0 {
		n += 2 + l + sovTest(uint64(l))
	}
	if len(m.Base58Repeated) > 0 {
		for _, b := range m.Base58Repeated {
			l = len(b)
			n += 2 + l + sovTest(uint64(l))
		}
	}
	l = len(m.Multiaddr)
	if l > 0 {
		n += 2 + l + sovTest(uint64(l))
	}
	if len(m.MultiaddrRepeated) > 0 {
		for _, b := range m.MultiaddrRepeated {
			l = len(b)
			n += 2 + l + sovTest(uint64(l))
		}
	}
	if m.Time != 0 {
		n += 2 + sovTest(uint64(m.Time))
	}
	if len(m.TimeRepeated) > 0 {
		l = 0
		for _, e := range m.TimeRepeated {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if m.Duration != 0 {
		n += 2 + sovTest(uint64(m.Duration))
	}
	if len(m.DurationRepeated) > 0 {
		l = 0
		for _, e := range m.DurationRepeated {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if m.Bytesize != 0 {
		n += 2 + sovTest(uint64(m.Bytesize))
	}
	if len(m.BytesizeRepeated) > 0 {
		l = 0
		for _, e := range m.BytesizeRepeated {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if m.Byterate != 0 {
		n += 2 + sovTest(uint64(m.Byterate))
	}
	if len(m.ByterateRepeated) > 0 {
		l = 0
		for _, e := range m.ByterateRepeated {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	return n
}

func sovTest(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTest(x uint64) (n int) {
	return sovTest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Noext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrRepeated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StrRepeated = append(m.StrRepeated, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Boolean", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Boolean = bool(v != 0)
		case 13:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BooleanRepeated = append(m.BooleanRepeated, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BooleanRepeated = append(m.BooleanRepeated, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BooleanRepeated", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I32", wireType)
			}
			m.I32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.I32 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.I32Repeated = append(m.I32Repeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.I32Repeated = append(m.I32Repeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field I32Repeated", wireType)
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U32", wireType)
			}
			m.U32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.U32 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.U32Repeated = append(m.U32Repeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.U32Repeated = append(m.U32Repeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U32Repeated", wireType)
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I64", wireType)
			}
			m.I64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.I64 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.I64Repeated = append(m.I64Repeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.I64Repeated = append(m.I64Repeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field I64Repeated", wireType)
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U64", wireType)
			}
			m.U64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.U64 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.U64Repeated = append(m.U64Repeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.U64Repeated = append(m.U64Repeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U64Repeated", wireType)
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buf = append(m.Buf[:0], dAtA[iNdEx:postIndex]...)
			if m.Buf == nil {
				m.Buf = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufRepeated", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufRepeated = append(m.BufRepeated, make([]byte, postIndex-iNdEx))
			copy(m.BufRepeated[len(m.BufRepeated)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enumeration", wireType)
			}
			m.Enumeration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enumeration |= (Message_Enum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType == 0 {
				var v Message_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (Message_Enum(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EnumerationRepeated = append(m.EnumerationRepeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v Message_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (Message_Enum(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EnumerationRepeated = append(m.EnumerationRepeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumerationRepeated", wireType)
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base58", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base58 = append(m.Base58[:0], dAtA[iNdEx:postIndex]...)
			if m.Base58 == nil {
				m.Base58 = []byte{}
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base58Repeated", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base58Repeated = append(m.Base58Repeated, make([]byte, postIndex-iNdEx))
			copy(m.Base58Repeated[len(m.Base58Repeated)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiaddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Multiaddr = append(m.Multiaddr[:0], dAtA[iNdEx:postIndex]...)
			if m.Multiaddr == nil {
				m.Multiaddr = []byte{}
			}
			iNdEx = postIndex
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiaddrRepeated", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiaddrRepeated = append(m.MultiaddrRepeated, make([]byte, postIndex-iNdEx))
			copy(m.MultiaddrRepeated[len(m.MultiaddrRepeated)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TimeRepeated = append(m.TimeRepeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TimeRepeated = append(m.TimeRepeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRepeated", wireType)
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DurationRepeated = append(m.DurationRepeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DurationRepeated = append(m.DurationRepeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationRepeated", wireType)
			}
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytesize", wireType)
			}
			m.Bytesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytesize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BytesizeRepeated = append(m.BytesizeRepeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BytesizeRepeated = append(m.BytesizeRepeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesizeRepeated", wireType)
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Byterate", wireType)
			}
			m.Byterate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Byterate |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ByterateRepeated = append(m.ByterateRepeated, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ByterateRepeated = append(m.ByterateRepeated, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ByterateRepeated", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTest
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTest
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTest(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTest = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTest   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/stratumn/alice/cli/grpc/test/test.proto", fileDescriptorTest)
}

var fileDescriptorTest = []byte{
	// 928 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0xcf, 0x6f, 0xdc, 0x44,
	0x14, 0xc7, 0xe3, 0x7a, 0xd3, 0x26, 0x93, 0xfd, 0x95, 0xc9, 0xb6, 0x19, 0x0a, 0x6c, 0xa7, 0x2b,
	0x81, 0x2c, 0x54, 0x79, 0x2b, 0xdb, 0x31, 0x85, 0x14, 0x04, 0x96, 0xca, 0x89, 0x1f, 0xd2, 0x16,
	0x84, 0x84, 0x90, 0x90, 0xbd, 0x3b, 0x1b, 0x2c, 0x76, 0xbd, 0x89, 0x3d, 0x53, 0xa5, 0x1c, 0xf9,
	0x0b, 0x38, 0xe6, 0xec, 0x13, 0xff, 0x00, 0x27, 0x83, 0xe0, 0xd8, 0x23, 0x37, 0xae, 0x28, 0xfc,
	0x03, 0x1c, 0x39, 0xa2, 0x79, 0x63, 0x8f, 0xd7, 0x4b, 0x85, 0x82, 0x04, 0x87, 0xee, 0x8e, 0xdf,
	0x7b, 0xdf, 0xf7, 0xf9, 0xbe, 0xf1, 0x4c, 0xb3, 0xc8, 0x39, 0x89, 0xf9, 0x97, 0x22, 0xb2, 0xa7,
	0xab, 0xe5, 0x38, 0xe3, 0x69, 0xc8, 0xc5, 0x32, 0x19, 0x87, 0x8b, 0x78, 0xca, 0xc6, 0xd3, 0x45,
	0x3c, 0x3e, 0x49, 0x4f, 0xa7, 0x63, 0xce, 0x32, 0x0e, 0x1f, 0xf6, 0x69, 0xba, 0xe2, 0x2b, 0xfc,
	0x52, 0x55, 0x68, 0x43, 0xa1, 0x3d, 0x5d, 0xc4, 0xb6, 0x2c, 0xb4, 0x65, 0xcd, 0xed, 0xfb, 0x57,
	0xe8, 0xc8, 0xce, 0xb9, 0xfc, 0xa7, 0xfa, 0x8d, 0x7e, 0xed, 0xa0, 0x1b, 0x1f, 0xb0, 0x2c, 0x0b,
	0x4f, 0x18, 0x1e, 0xa0, 0xed, 0x64, 0xc5, 0xce, 0x39, 0x31, 0xa8, 0x61, 0xed, 0x4e, 0xd4, 0x03,
	0xb6, 0x90, 0x99, 0xb2, 0x33, 0x72, 0x4d, 0xc6, 0x82, 0x5b, 0x79, 0x41, 0xba, 0x29, 0x3b, 0x13,
	0x71, 0xca, 0x66, 0x74, 0x1e, 0xb3, 0xc5, 0xec, 0xbb, 0x82, 0x18, 0x13, 0x59, 0x82, 0x47, 0xc8,
	0xcc, 0x78, 0x4a, 0x10, 0x54, 0xf6, 0xf3, 0x82, 0xb4, 0x33, 0x9e, 0xc6, 0xc9, 0x89, 0xaa, 0x9b,
	0xc8, 0x24, 0x7e, 0x88, 0x64, 0xf0, 0x8b, 0x94, 0x9d, 0xb2, 0x90, 0xb3, 0x19, 0xd9, 0xa3, 0xa6,
	0xb5, 0x1b, 0xbc, 0x90, 0x17, 0xe4, 0x66, 0x59, 0x5c, 0xa5, 0x4a, 0xd5, 0x5e, 0xc6, 0xd3, 0x49,
	0x19, 0xc2, 0x16, 0xba, 0x11, 0xad, 0x56, 0x0b, 0x16, 0x26, 0xa4, 0x4d, 0x0d, 0x6b, 0x27, 0xe8,
	0xe6, 0x05, 0x41, 0x32, 0x54, 0x56, 0x57, 0x69, 0x1c, 0xa0, 0x7e, 0xb9, 0xac, 0x59, 0x1d, 0x6a,
	0x5a, 0x3b, 0xc1, 0x61, 0x5e, 0x90, 0x03, 0x90, 0x6c, 0x90, 0x7a, 0xa5, 0x40, 0xd3, 0xee, 0x22,
	0x33, 0x76, 0x1d, 0xd2, 0xa5, 0x86, 0xb5, 0x1d, 0xf4, 0xf2, 0x82, 0xec, 0xc5, 0x09, 0x77, 0x9d,
	0x6a, 0x9c, 0xd8, 0x75, 0xf0, 0x31, 0x6a, 0xc7, 0xae, 0x53, 0x23, 0x7a, 0xd4, 0xb4, 0x3a, 0x01,
	0xc9, 0x0b, 0x32, 0x50, 0xb5, 0x9b, 0xd3, 0xc4, 0xae, 0xa3, 0xfb, 0x8f, 0x90, 0x29, 0x5c, 0x87,
	0xf4, 0xa9, 0x61, 0x75, 0xd4, 0x7e, 0x89, 0x06, 0x40, 0xb8, 0x8e, 0xdc, 0x2f, 0xb1, 0x0e, 0xd8,
	0x07, 0x00, 0xec, 0x97, 0x78, 0x3e, 0x41, 0xac, 0x11, 0xe4, 0x04, 0xbe, 0x47, 0x30, 0x35, 0x2c,
	0x53, 0x4f, 0xe0, 0x7b, 0x7a, 0x02, 0xdf, 0x83, 0x09, 0x7c, 0xaf, 0x06, 0x1c, 0x50, 0xd3, 0x32,
	0xf5, 0x04, 0xbe, 0xf7, 0xf7, 0x09, 0x7c, 0xaf, 0x31, 0x81, 0xef, 0x91, 0x01, 0x35, 0xac, 0x56,
	0x3d, 0x41, 0x0d, 0x10, 0xbe, 0x07, 0x13, 0xac, 0x03, 0x6e, 0x52, 0xd3, 0x6a, 0xd5, 0x13, 0x3c,
	0x87, 0x20, 0xd6, 0x08, 0x77, 0x91, 0x19, 0x89, 0x39, 0xb9, 0x45, 0x0d, 0xab, 0xad, 0x26, 0x88,
	0x9e, 0x72, 0x96, 0x55, 0x80, 0x48, 0xcc, 0xe5, 0x04, 0x91, 0x98, 0xd7, 0x80, 0x43, 0x6a, 0x5a,
	0x6d, 0x35, 0x81, 0xaa, 0xdd, 0xec, 0x1f, 0x89, 0xb9, 0xee, 0xff, 0x39, 0xda, 0x63, 0x89, 0x58,
	0xb2, 0x34, 0xe4, 0xf1, 0x2a, 0x21, 0x43, 0x6a, 0x58, 0x5d, 0xe7, 0x35, 0xfb, 0x9f, 0x6e, 0x99,
	0x5d, 0xde, 0x17, 0xfb, 0x51, 0x22, 0x96, 0xea, 0x04, 0xca, 0x16, 0x55, 0xf7, 0xb5, 0x76, 0xf8,
	0x09, 0x1a, 0xac, 0x3d, 0xd6, 0x16, 0xef, 0x50, 0xf3, 0x5f, 0x62, 0xe0, 0xd4, 0x02, 0x66, 0x63,
	0x9a, 0x83, 0x35, 0x80, 0x9e, 0xea, 0x1e, 0xba, 0x1e, 0x85, 0x19, 0x3b, 0x7a, 0x40, 0x1c, 0xd8,
	0xb8, 0x81, 0x7c, 0x35, 0x2a, 0xa2, 0x64, 0x7f, 0xc8, 0x4b, 0x5b, 0xd6, 0xe0, 0xf7, 0x50, 0x4f,
	0xad, 0x6a, 0x83, 0x2e, 0xec, 0xe1, 0xcb, 0xf2, 0x25, 0x95, 0xb2, 0x26, 0x16, 0xf4, 0x5d, 0x95,
	0xd2, 0xd4, 0x23, 0xb4, 0xbb, 0x14, 0x0b, 0x1e, 0x87, 0xb3, 0x59, 0x4a, 0x3c, 0x00, 0x4b, 0xdb,
	0x3d, 0x1d, 0x54, 0xda, 0x3f, 0xa5, 0xb6, 0xae, 0xc4, 0x1f, 0x21, 0xac, 0x1f, 0x6a, 0x07, 0x47,
	0xe0, 0x80, 0xe6, 0x05, 0x21, 0xb5, 0xbe, 0x69, 0x02, 0x1a, 0xed, 0xeb, 0xac, 0xf6, 0xf1, 0x2a,
	0x6a, 0xf1, 0x78, 0xc9, 0x88, 0x0f, 0xc7, 0x1e, 0xcb, 0x17, 0x24, 0x9f, 0x95, 0xe8, 0xe7, 0x1f,
	0x88, 0x31, 0x81, 0x3c, 0x7e, 0x07, 0x75, 0xe4, 0x77, 0xcd, 0x7c, 0x1d, 0xce, 0xfe, 0x8b, 0x72,
	0xab, 0x41, 0xd0, 0xc4, 0x81, 0xb2, 0x2d, 0x13, 0x9a, 0xe4, 0xa0, 0x9d, 0x99, 0x28, 0x8f, 0xce,
	0x03, 0xa0, 0xc1, 0x7f, 0x90, 0x55, 0x4c, 0xe9, 0x9e, 0x49, 0x9d, 0xae, 0xc3, 0xef, 0xa3, 0xfd,
	0x6a, 0x5d, 0x93, 0xdf, 0x00, 0xf2, 0x9d, 0xbc, 0x20, 0x87, 0x5a, 0xdc, 0xa4, 0x43, 0x97, 0x7e,
	0x95, 0x5c, 0x77, 0x00, 0x87, 0x3c, 0xfe, 0x9a, 0x91, 0x37, 0xe1, 0x1a, 0x82, 0x83, 0x2a, 0xa6,
	0xb4, 0xdf, 0xfe, 0x28, 0x1d, 0x54, 0x31, 0xe9, 0xa0, 0x5a, 0xd7, 0x0e, 0x8e, 0xe1, 0x5a, 0x82,
	0x03, 0x2d, 0x6e, 0x3a, 0x80, 0x2e, 0xfd, 0x2a, 0xb9, 0xe9, 0x20, 0x0d, 0x39, 0x23, 0x0f, 0x9b,
	0x0e, 0x64, 0x4c, 0x69, 0x2f, 0xb4, 0x03, 0x19, 0xab, 0x1c, 0xc8, 0x75, 0xed, 0xe0, 0xad, 0xa6,
	0x03, 0x10, 0x37, 0x1d, 0x5c, 0x68, 0x07, 0x32, 0x59, 0x39, 0x18, 0x0d, 0x50, 0x4b, 0xde, 0x11,
	0xbc, 0x8d, 0x8c, 0x77, 0xfb, 0x5b, 0xf2, 0x2b, 0xe8, 0x1b, 0xce, 0x4f, 0xd7, 0x50, 0xeb, 0x63,
	0x96, 0x71, 0xfc, 0x15, 0xda, 0xf9, 0x24, 0x09, 0xd3, 0xa7, 0x13, 0x76, 0x86, 0x5f, 0xb9, 0xd2,
	0x95, 0xbb, 0x7d, 0xb5, 0xb2, 0xd1, 0xfe, 0x37, 0xdf, 0x93, 0x0e, 0xf4, 0xa6, 0xf2, 0x6f, 0xa2,
	0x84, 0x9d, 0xa1, 0xf6, 0x63, 0x96, 0x3e, 0x61, 0xe9, 0x63, 0x9e, 0xb2, 0x70, 0xf9, 0x7f, 0x00,
	0x55, 0x7f, 0x9a, 0x01, 0xe0, 0xbe, 0x81, 0x3f, 0x45, 0xdb, 0x1f, 0xae, 0x1e, 0x9d, 0xf3, 0xff,
	0x98, 0xb5, 0x15, 0xbc, 0xfd, 0xec, 0x72, 0x68, 0xfc, 0x72, 0x39, 0x34, 0x7e, 0xbb, 0x1c, 0x1a,
	0x17, 0xbf, 0x0f, 0xb7, 0x3e, 0xbb, 0x77, 0xc5, 0x5f, 0x2c, 0xc7, 0xf2, 0x23, 0xba, 0x0e, 0x3f,
	0x31, 0xdc, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x8f, 0xa9, 0xad, 0x97, 0xe8, 0x08, 0x00, 0x00,
}
