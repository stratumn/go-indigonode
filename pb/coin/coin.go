// Copyright Â© 2017-2018 Stratumn SAS
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package coin

import (
	"encoding/hex"
	"errors"

	peer "gx/ipfs/QmZoWKhxUmZ2seW4BzX6fJkNR8hh9PsGModr7q171yq2SS/go-libp2p-peer"
)

// The goal of this file is to enrich the model generated by protoc.

var (
	// ErrBadResponseType is returned when a call to a peer returns an
	// unexpected response type.
	ErrBadResponseType = errors.New("bad response type")
)

// BlockNumber returns the number of a block.
func (b *Block) BlockNumber() uint64 {
	if b.Header == nil {
		return 0
	}
	return b.Header.BlockNumber
}

// PreviousHash returns the hash of previous block's header.
func (b *Block) PreviousHash() []byte {
	if b.Header == nil {
		return []byte{}
	}
	return b.Header.PreviousHash
}

// Nonce returns the nonce of the block's header.
func (b *Block) Nonce() uint64 {
	if b.Header == nil {
		return 0
	}
	return b.Header.Nonce
}

// Loggable returns a loggable form of a header.
func (h *Header) Loggable() map[string]interface{} {
	loggable := make(map[string]interface{})
	loggable["block_number"] = h.BlockNumber
	loggable["nonce"] = h.Nonce
	loggable["merkle_root"] = hex.EncodeToString(h.MerkleRoot)
	loggable["previous_hash"] = hex.EncodeToString(h.PreviousHash)

	return loggable
}

// Loggable returns a loggable form of a block.
func (b *Block) Loggable() map[string]interface{} {
	loggable := make(map[string]interface{})

	if b.Header != nil {
		loggable["header"] = b.Header.Loggable()
	}

	txs := make([]map[string]interface{}, len(b.Transactions))
	for i, tx := range b.Transactions {
		txs[i] = tx.Loggable()
	}
	loggable["txs"] = txs

	return loggable
}

// Loggable returns a loggable form of a transaction.
func (tx *Transaction) Loggable() map[string]interface{} {
	loggable := make(map[string]interface{})

	from, err := peer.IDFromBytes(tx.From)
	if err == nil {
		loggable["from"] = peer.IDB58Encode(from)
	}

	to, err := peer.IDFromBytes(tx.To)
	if err == nil {
		loggable["to"] = peer.IDB58Encode(to)
	}

	loggable["value"] = tx.Value
	loggable["fee"] = tx.Fee
	loggable["nonce"] = tx.Nonce

	return loggable
}

// NewHeaderRequest returns a request object of type HeaderReq.
func NewHeaderRequest(hash []byte) *Request {
	return &Request{
		Msg: &Request_HeaderReq{
			HeaderReq: &HeaderRequest{Hash: hash},
		},
	}
}

// GetHeader returns the Header of a HeaderRsp or fails
// for other response types.
func (rsp *Response) GetHeader() (*Header, error) {
	h, ok := rsp.Msg.(*Response_HeaderRsp)
	if !ok {
		return nil, ErrBadResponseType
	}

	return h.HeaderRsp, nil
}

// NewHeaderResponse returns a response object of type HeaderRsp.
func NewHeaderResponse(header *Header) *Response {
	return &Response{
		Msg: &Response_HeaderRsp{
			HeaderRsp: header,
		},
	}
}

// NewHeadersRequest returns a request object of type HeadersReq.
func NewHeadersRequest(from, amount uint64) *Request {
	return &Request{
		Msg: &Request_HeadersReq{
			HeadersReq: &HeadersRequest{From: from, Amount: amount},
		},
	}
}

// GetHeaders returns the Headers of a HeadersRsp or fails
// for other response types.
func (rsp *Response) GetHeaders() ([]*Header, error) {
	h, ok := rsp.Msg.(*Response_HeadersRsp)
	if !ok {
		return nil, ErrBadResponseType
	}

	return h.HeadersRsp.Headers, nil
}

// NewHeadersResponse returns a response object of type HeadersRsp.
func NewHeadersResponse(headers []*Header) *Response {
	return &Response{
		Msg: &Response_HeadersRsp{
			HeadersRsp: &Headers{Headers: headers},
		},
	}
}

// NewBlockRequest returns a request object of type BlockReq.
func NewBlockRequest(hash []byte) *Request {
	return &Request{
		Msg: &Request_BlockReq{
			BlockReq: &BlockRequest{Hash: hash},
		},
	}
}

// GetBlock returns the Block of a BlockRsp or fails
// for other response types.
func (rsp *Response) GetBlock() (*Block, error) {
	h, ok := rsp.Msg.(*Response_BlockRsp)
	if !ok {
		return nil, ErrBadResponseType
	}

	return h.BlockRsp, nil
}

// NewBlockResponse returns a response object of type BlockRsp.
func NewBlockResponse(header *Block) *Response {
	return &Response{
		Msg: &Response_BlockRsp{
			BlockRsp: header,
		},
	}
}

// NewBlocksRequest returns a request object of type BlocksReq.
func NewBlocksRequest(from, amount uint64) *Request {
	return &Request{
		Msg: &Request_BlocksReq{
			BlocksReq: &BlocksRequest{From: from, Amount: amount},
		},
	}
}

// GetBlocks returns the Blocks of a BlocksRsp or fails
// for other response types.
func (rsp *Response) GetBlocks() ([]*Block, error) {
	h, ok := rsp.Msg.(*Response_BlocksRsp)
	if !ok {
		return nil, ErrBadResponseType
	}

	return h.BlocksRsp.Blocks, nil
}

// NewBlocksResponse returns a response object of type BlocksRsp.
func NewBlocksResponse(blocks []*Block) *Response {
	return &Response{
		Msg: &Response_BlocksRsp{
			BlocksRsp: &Blocks{Blocks: blocks},
		},
	}
}
