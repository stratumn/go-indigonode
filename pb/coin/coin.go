// Copyright Â© 2017-2018 Stratumn SAS
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package coin

import (
	"encoding/hex"

	peer "gx/ipfs/Qma7H6RW8wRrfZpNSXwxYGcd1E149s42FpWNpDNieSVrnU/go-libp2p-peer"
)

// The goal of this file is to enrich the model generated by protoc.

// BlockNumber returns the number of a block.
func (b *Block) BlockNumber() uint64 {
	if b.Header == nil {
		return 0
	}
	return b.Header.BlockNumber
}

// PreviousHash returns the hash of previous block's header
func (b *Block) PreviousHash() []byte {
	if b.Header == nil {
		return []byte{}
	}
	return b.Header.PreviousHash
}

// Nonce returns the nonce of the block's header.
func (b *Block) Nonce() uint64 {
	if b.Header == nil {
		return 0
	}
	return b.Header.Nonce
}

// Loggable returns a loggable form of a header.
func (h *Header) Loggable() map[string]interface{} {
	loggable := make(map[string]interface{})
	loggable["block_number"] = h.BlockNumber
	loggable["nonce"] = h.Nonce
	loggable["merkle_root"] = hex.EncodeToString(h.MerkleRoot)
	loggable["previous_hash"] = hex.EncodeToString(h.PreviousHash)

	return loggable
}

// Loggable returns a loggable form of a block.
func (b *Block) Loggable() map[string]interface{} {
	loggable := make(map[string]interface{})

	if b.Header != nil {
		loggable["header"] = b.Header.Loggable()
	}

	txs := make([]map[string]interface{}, len(b.Transactions))
	for i, tx := range b.Transactions {
		txs[i] = tx.Loggable()
	}
	loggable["txs"] = txs

	return loggable
}

// Loggable returns a loggable form of a transaction.
func (tx *Transaction) Loggable() map[string]interface{} {
	loggable := make(map[string]interface{})

	from, err := peer.IDFromBytes(tx.From)
	if err == nil {
		loggable["from"] = peer.IDB58Encode(from)
	}

	to, err := peer.IDFromBytes(tx.To)
	if err == nil {
		loggable["to"] = peer.IDB58Encode(to)
	}

	loggable["value"] = tx.Value
	loggable["fee"] = tx.Fee
	loggable["nonce"] = tx.Nonce

	return loggable
}
